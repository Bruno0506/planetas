from picamera2 import Picamera2
import cv2
import numpy as np

# Inicializar la cámara
picam2 = Picamera2()
picam2.configure(picam2.create_still_configuration({"size": (1280, 720)}))  # Ajusta la resolución según sea necesario
picam2.start()

# Cargar tus pesos y configuración de YOLO
# Asegúrate de tener las rutas correctas
weights_path = 'yolov4-tiny.weights'  # Ruta a los pesos de YOLO
config_path = 'yolov4-tiny.cfg'  # Ruta al archivo de configuración de YOLO
net = cv2.dnn.readNet(weights_path, config_path)

# Cargar las clases de objetos
with open('coco.names', 'r') as f:
    classes = [line.strip() for line in f.readlines()]

# Iniciar la captura de video
try:
    while True:
        # Capturar un frame
        frame = picam2.capture_array()
        
        # Verifica que el frame sea un array de NumPy
        if isinstance(frame, np.ndarray):
            # Preparar el frame para la detección
            blob = cv2.dnn.blobFromImage(frame, 0.00392, (416, 416), (0, 0, 0), True, crop=False)
            net.setInput(blob)

            # Obtener las salidas de la red
            layer_names = net.getLayerNames()
            output_layers = [layer_names[i[0] - 1] for i in net.getUnconnectedOutLayers()]
            outs = net.forward(output_layers)

            # Procesar las detecciones
            for out in outs:
                for detection in out:
                    scores = detection[5:]  # Las probabilidades de clase
                    class_id = np.argmax(scores)
                    confidence = scores[class_id]

                    # Filtrar detecciones por confianza
                    if confidence > 0.5:  # Ajusta este umbral según sea necesario
                        # Obtener coordenadas del bounding box
                        center_x = int(detection[0] * frame.shape[1])
                        center_y = int(detection[1] * frame.shape[0])
                        w = int(detection[2] * frame.shape[1])
                        h = int(detection[3] * frame.shape[0])

                        # Calcular los bordes del bounding box
                        x = int(center_x - w / 2)
                        y = int(center_y - h / 2)

                        # Dibujar el bounding box y el texto
                        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
                        cv2.putText(frame, f"{classes[class_id]}: {confidence:.2f}", (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)

            # Mostrar el frame con detecciones
            cv2.imshow("Detección de Objetos", frame)

            # Salir del bucle si se presiona 'q'
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        else:
            print("Error: El frame capturado no es un array de NumPy.")
finally:
    # Cerrar la cámara y las ventanas al finalizar
    picam2.close()
    cv2.destroyAllWindows()
